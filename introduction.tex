\XeTeXinputencoding "GBK"                                   % 本文件采用GBK编码

\chapter{导~言}
在这一章节中，我们为本书的后续部分设定了阶段。我们从回顾函数的概念开始，然后介绍函数式编程的概念，总结Haskell的主要特点和它的历史，最后通过两个小例子“品尝”一下Haskell的味道。

\section{函数}
在Haskell中，一个函数是一个映射，它有一个或多个参数，并产生唯一一个结果。我们可以通过一个等式来定义函数，等式中包含函数的名字、函数参数的名字以及详细描述如何依据参数计算出结果的函数体。

例如，一个名为double的函数，参数是一个数字x，产生的结果为x~+~x，可通过如下等式定义：
\[ \begin{split}
double~x = x + x
\end{split} \]

当一个函数被应用到实际参数时，其结果可通过将实际参数替换函数体中的参数名称的方式获得。这个过程可能会立即产生一个不能被进一步简化的结果，比如一个数字。而更为常见的情况是，这个结果是一个含有其他函数程序的表达式，它必须被以同样的方式处理才能产生最终的结果。

例如，程序double 3将函数double应用到数字3的结果可通过以下计算过程得出，每一步计算通过花括号里简短注释解释：
\[ \begin{split}
double~3\\ 
= \{applying~double\} \\
3 + 3\\
= \{applying +\}\\
6
\end{split} \]

同样，两次应用double的内嵌程序double (double 2)的结果可以通过如下计算过程得出：

\[ \begin{split}
double~(double~2)\\
= \{applying~the~inner~double\}\\
double~(2~+~2)\\
= \{applying~+~\}\\
double~4\\
= \{applying~double \}\\
4+4\\
= \{applying~+\}\\
8
\end{split} \]

另外，同样的结果也可以通过先从外层的函数double开始计算获得：
\[ \begin{split}
double~(double~2)\\
=\{applying~the~outer~double\}\\
double~2~+~double~2\\
=\{applying~the~first~double\}\\
(2~+~2)~+~double~2\\
=\{applying~the~first~+~\}\\
4~+~double~2\\
= \{applying~double\}\\
4~+~(2~+~2)\\
= \{applying~the~second~+\}\\
4+4\\
= \{applying~+~\}\\
8
\end{split} \]

但是，这个计算过程比我们原来的版本多出两步，因为表达式double 2在第一步中被复制了一份并因此被化简了两次。一般来说，函数在计算过程中应用的顺序不会影响最终的结果值，但它可能会影响到所需步骤的数量，并可能影响计算过程是否终止的判断。本书第12章针对这些问题作了更为详细的探究。

\section{函数式编程}

什么是函数式编程？见仁见智，很难给出一个确切的定义。但总的来说，函数式编程可以被看作一种编程风格，这种风格的基本计算方式是将函数应用于实际参数。相应的，一门函数式编程语言就是支持和鼓励使用函数式风格的计算机编程语言。

为了说明这些概念，让我们考虑一个计算从1到n的整数和的任务吧。在当前大多数编程语言中，这个任务通常可以通过使用两个可随时改变的存储值变量实现，一个变量从1变到n，另外一个变量用来累加总数。

例如，如果我们使用赋值符号:=来改变一个变量的值，使用关键字repeat和until来反复执行一个指令序列，直到某个条件被满足，那么下面的指令序列计算出所需的总和：

\begin{verbatim}
count := 0
total := 0
repeat
    count := count + 1
    total := total + count
until
    count = n
\end{verbatim}

也就是说，我们首先将计数器和总和这两个变量初始化为零，然后反复递增计数器，并把这个值与总和变量相加，直到计数器达到n，此时计算过程停止。

在上述程序中，计算的基本方法是改变存储的值，在某种意义上说，程序执行就是一系列的赋值操作。例如，n
= 5时我们得到如下序列，其中最后赋给变量total的值就是所需的总和：

\begin{verbatim}
count := 0
total := 0
count := 1
total := 1
count := 2
total := 3
count := 3
total := 6
count := 4
total := 10
count := 5
total := 15
\end{verbatim}

通常，这种以改变存储值为基本计算方式的编程语言被称为命令式语言，因为用这类语言编写的程序由一系列命令式指令构成，这些指令精确描述了计算过程应该如何进行。

现在让我们考虑使用Haskell来计算从1到n的整数和。这通常使用两个库函数，一个是[..]，用于产生从1到n之间的数字列表，另外一个是sum，用于针对这个列表求和。 

\begin{verbatim}
sum [1..n]
\end{verbatim}

在这个程序中，计算的基本方法是将函数应用于参数。在这个意义上，程序的执行过程实际上是一系列的函数应用。比如当n = 5时，我们得到如下序列，最终结果就是我们所需要的总和：

\begin{verbatim}
sum [1..5]
= { applying [..] }
sum [1, 2, 3, 4, 5]
= { applying sum }
1+2+3+4+5
= { applying + }
15
\end{verbatim}

大多数命令式语言都支持一些使用函数编程的形式，所以Haskell程序sum [1..n]可以被转化成这些语言。但是，大多数命令式语言不鼓励使用函数式风格编程。比如，大多数语言不鼓励或禁止函数被存储在类似列表的数据结构中，或构建类似上面例子中数字列表那样的中间结构; 或接收函数作为参数或将函数作为返回值; 或被自己定义。相反，Haskell在如何使用函数上没有这些限制，并且提供了一系列功能特色，使得使用函数进行编程既简单又强大。

\section{Haskell的特点}
\begin{itemize}
\item 简明的程序 (第二章和第四章)

由于函数式风格抽象层次高的本质，使用Haskell编写的程序往往比用其他语言更加简明，正如上一节例子中说明的那样。此外，Haskell的语法设计充分考虑了简明的特点，尤其是拥有较少的关键字，并允许使用缩进来表示程序结构。虽然很难作出客观的比较，但Haskell编写的程序往往比其他当前语言编写的程序短小2-10倍。\newline

\item 强大的类型系统（第三章和第十章）

大多数现代编程语言都包含某种形式的类型系统来检测不兼容错误，如试图将一个数字和一个字符相加。Haskell有一个类型系统，它仅从程序员那里获取很少量的类型信息，但却可以在程序执行之前使用一种被称为类型推断的过程自动检查出大量不兼容的错误。Haskell的类型系统也比大多数现代编程语言更为强大，它允许函数是“多态的”和“重载的”。\newline

\item 列表理解（第五章）

在计算中一种最常见的结构化和操作数据的方法就是使用列表。为此，Haskell提供列表作为语言的一种基本概念，并连同一个简单但功能强大的理解符号，使用这些符号我们可以通过从已有列表中选择或过滤元素来构建新列表。理解符号的使用使得列表上许多公共函数以一种清晰、简明的方式定义出来，而不需要显式的递归。

\item 递归函数（第六章）

大多数实用程序都包含一些形式的重复或循环。在Haskell中，实现循环的基本机制是使用嵌套了自己定义的递归函数。许多计算都能用递归函数给出一个简单和自然的定义，particularly when “pattern matching” and “guards” are used to separate different cases into
different equations。

\item 高阶（第七章）

Haskell是一门高阶函数式编程语言，这意味着在函数定义中你可以自由将函数作为参数和结果返回值。使用高阶函数接受常见的编程模式，such as composing two functions, to be defined as functions within the language itself.
更常见的是在Haskell中高阶函数可以用于定义“领域特定语言”，比如列表处理、解析以及交互式编程。

\item Monadic作用（第八章和第九章）

Haskell中的函数都是纯函数，它们将所有输入作为参数，将所有输出作为结果返回。但是，许多程序需要某种形式的副作用，这似乎与纯洁性有冲突。比如当程序运行时从键盘读取输入或输出结果到屏幕。Haskell提供了一个不损害函数纯洁性的基于monad数学概念的处理副作用的统一框架。

\item 惰性求值（第十二章）

Haskell程序的执行使用了一种叫惰性求值的技术，这种技术的基本思想是直到其结果是实际需要的时候，计算才应该被执行。除了避免不必要的计算，惰性求值保证程序适时结束，鼓励以使用中间数据结构的模块式风格进行编程，甚至允许使用拥有无穷元素个数的数据结构，比如一个无穷的数字列表。

\item 程序推理

因为在Haskell中程序是纯函数，所以简单的等式推理可用于执行程序，变换程序，证明程序属性，甚至能够从他们的行为规范中直接提取出程序。在结合使用归纳方法对递归函数进行推理时，等式推理特别强大。
\end{itemize}

\section{历史背景}
Haskell的许多特色并非首创，都是由其他语言首次引入的。To help place Haskell in context，下面简要总结一下有关Haskell语言的一些主要的历史性的发展： 

\begin{itemize}
\item 20世纪30年代，Alonzo Church发明了lambda演算，一种简单但功能强大的数学函数理论。
\item 20世纪50年代，John McCarthy发明了Lisp(列表处理器)，Lisp被公认为是世上第一种函数式编程语言。Lisp许多方面受到了lambda演算的影响，但同时仍然接受变量赋值作为语言的一个核心特征。
\item 20世纪60年代，Peter Landin发明了ISWIN(“If you See What I Mean”)，第一种纯函数式编程语言，它主要基于lambda演算，并且没有变量赋值。
\item 20世纪70年代，John Backus发明了FP("Fuctional Programming")，一种特别强调高阶函数和程序推理思想的语言。
\item 同样也是在20世纪70年代，Robin Milner和其他人一起开发了ML(元语言），第一种现代函数式编程语言，引入了多态类型和类型推断思想。
\item 20世纪70年代和80年代，David Turner 开发出许多惰性的函数式编程语言，最终造就了可获得商业支持的Miranda（意为"令人敬佩的"）语言的出现。
\item 1987年，一个国际研究委员会发起开发Haskell语言（以逻辑学家Haskell Curry命名），一个标准的惰性函数式编程语言。
\item 2003年，该委员会公布了Haskell的报告，报告中定义了一个期待已久的Haskell的稳定版本，该版本是该语言设计者们十五年工作的成果。
\end{itemize}
