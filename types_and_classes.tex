\XeTeXinputencoding "GBK"                                   % 本文件采用GBK编码

\chapter{类型和类}
在这一章节中，我们将介绍Haskell中两个最基础的概念：类型和类。我们首先解释什么是类型以及在Haskell中如何使用它，然后介绍一些基本类型以及使用这些基本类型构造更大的类型的方法，详细讨论函数类型，最后介绍一下多态类型和类型类。

\section{基本概念}
\textit{类型}是一组相关值的集合。例如，类型Bool包含两个逻辑值\textit{False}和\textit{True}，而类型\textit{Bool
->
Bool}则包含了所有将Bool类型参数映射为Bool类型结果的函数，如逻辑非函数\textit{not}。我们使用符号\textit{v::T}来表示\textit{v}是类型\textit{T}的一个值，并可说成\textit{v}具有类型\textit{T}。例如：

\begin{verbatim}
False :: Bool
True :: Bool
not :: Bool -> Bool
\end{verbatim}

更一般的是，符号::也可以用于尚未被求值的表达式，这种情况下，e::\textit{T}意为对表达式\textit{e}求值将产生一个类型\textit{T}的值。例如：

\begin{verbatim}
not False :: Bool
not True :: Bool
not (not False):: Bool
\end{verbatim}

在Haskell中，每个表达式必须有一个类型，该类型通过一个先于表达式求值的过程计算得到，这个过程被称为\textit{类型推断}。这个过程的关键在于一个函数应用的类型规则。其中规定如果f是一个将类型A参数映射为类型B结果的函数，e是一个A类型的表达式，那么f~~e具有类型B：\\
\\
$\dfrac{f::A->B~~e::A}{f~e::B}$
\\
\\
例如，\textit{not False::Bool}可通过这样的规则推断，该规则使用了这样的事实：\textit{not::Bool->Bool}和\textit{False::Bool}。另一方面，表达式\textit{not 3}通过上述规则无法推断类型，因为这需要\textit{3::Bool}，但3不是一个逻辑值，这是无效的。像\textit{not 3}这样的表达式无法确定类型，也可以说成是包含了一个类型错误，被视为非法表达式。

由于类型推断在求值过程之前，所以Haskell程序是类型安全的，也就是说在求值过程中不会发生类型错误。实际上，类型推断能检查出程序中所占错误比例较高的一类错误，它也是Haskell最有用的特性之一。但是注意使用类型推断并不能消除发生在求值阶段的其他类错误的可能性，比如，表达式\textit{1
'div' 0}可以通过类型推断检查，但在求值阶段报错，因为被0除的行为是未定义的。

类型安全的不足之处在于一些求值阶段成功的表达式却因类型原因而被拒绝。例如，条件表达式\textbf{if} \textit{True} \textbf{then} \textit{1} \textbf{else}
\textit{False}求值结果为1, 但是因包含一个类型错误而被视为无效表达式。
特别是，条件表达式的类型推断规则要求所有可能的结果都具有相同的类型，而在这里例子中，第一种结果为1，是一个数字类型，而第二个结果是False，是一个逻辑值类型。在实践中，程序员很快就学会了如何在类型系统的限制下工作以及如何避免这些问题。

In Hugs, the type of any expression can be displayed by preceding the expression by the command :type . For example:

在Hugs系统中，任意表达式的类型都可以通过\textit{:type}显示出来，例如：

\begin{verbatim}
> :type not
not :: Bool -> Bool

> :type not False
not False :: Bool

> :type not 3
Error
\end{verbatim}

\section{基本类型}

