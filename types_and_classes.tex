\XeTeXinputencoding "GBK"                                   % 本文件采用GBK编码

\chapter{类型和类}
在这一章节中，我们将介绍Haskell中两个最基础的概念：类型和类。我们首先解释什么是类型以及在Haskell中如何使用它，然后介绍一些基本类型以及使用这些基本类型构造更大的类型的方法，详细讨论函数类型，最后介绍一下多态类型和类型类。

\section{基本概念}
\textit{类型}是一组相关值的集合。例如，类型Bool包含两个逻辑值\textit{False}和\textit{True}，而类型\textit{Bool
->
Bool}则包含了所有将Bool类型参数映射为Bool类型结果的函数，如逻辑非函数\textit{not}。我们使用符号\textit{v::T}来表示\textit{v}是类型\textit{T}的一个值，并可说成\textit{v}具有类型\textit{T}。例如：

\begin{verbatim}
False :: Bool
True :: Bool
not :: Bool -> Bool
\end{verbatim}

更一般的是，符号::也可以用于尚未被求值的表达式，这种情况下，e::\textit{T}意为对表达式\textit{e}求值将产生一个类型\textit{T}的值。例如：

\begin{verbatim}
not False :: Bool
not True :: Bool
not (not False):: Bool
\end{verbatim}

在Haskell中，每个表达式必须有一个类型，该类型通过一个先于表达式求值的过程计算得到，这个过程被称为\textit{类型推断}。这个过程的关键在于一个函数应用的类型规则。其中规定如果f是一个将类型A参数映射为类型B结果的函数，e是一个A类型的表达式，那么f~~e具有类型B：\\
\\
$\dfrac{f::A->B~~e::A}{f~e::B}$
\\
\\
例如，\textit{not False::Bool}可通过这样的规则推断，该规则使用了这样的事实：\textit{not::Bool->Bool}和\textit{False::Bool}。另一方面，表达式\textit{not 3}通过上述规则无法推断类型，因为这需要\textit{3::Bool}，但3不是一个逻辑值，这是无效的。像\textit{not 3}这样的表达式无法确定类型，也可以说成是包含了一个类型错误，被视为非法表达式。

由于类型推断在求值过程之前，所以Haskell程序是类型安全的，也就是说在求值过程中不会发生类型错误。
