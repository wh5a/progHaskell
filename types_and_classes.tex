%\XeTeXinputencoding "GBK"                                   % 本文件采用GBK编码

\chapter{类型和类}
在这一章节中，我们将介绍Haskell中两个最基础的概念：类型和类。我们首先解释什么是类型以及在Haskell中如何使用它，然后介绍一些基本类型以及使用这些基本类型构造更大的类型的方法，详细讨论函数类型，最后介绍一下多态类型和类型类。

\section{基本概念}
\textit{类型}是一组相关值的集合。例如，类型Bool包含两个逻辑值\textit{False}和\textit{True}，而类型\textit{Bool
->
Bool}则包含了所有将Bool类型参数映射为Bool类型结果的函数，如逻辑非函数\textit{not}。我们使用符号\textit{v::T}来表示\textit{v}是类型\textit{T}的一个值，并可说成\textit{v}具有类型\textit{T}。例如：

\begin{verbatim}
False :: Bool
True :: Bool
not :: Bool -> Bool
\end{verbatim}

更一般的是，符号::也可以用于尚未被求值的表达式，这种情况下，e::\textit{T}意为对表达式\textit{e}求值将产生一个类型\textit{T}的值。例如：

\begin{verbatim}
not False :: Bool
not True :: Bool
not (not False):: Bool
\end{verbatim}

在Haskell中，每个表达式必须有一个类型，该类型通过一个先于表达式求值的过程计算得到，这个过程被称为\textit{类型推断}。这个过程的关键在于一个函数应用的类型规则。其中规定如果f是一个将类型A参数映射为类型B结果的函数，e是一个A类型的表达式，那么f~~e具有类型B：\\
\\
$\dfrac{f::A->B~~e::A}{f~e::B}$
\\
\\
例如，\textit{not False::Bool}可通过这样的规则推断，该规则使用了这样的事实：\textit{not::Bool->Bool}和\textit{False::Bool}。另一方面，表达式\textit{not 3}通过上述规则无法推断类型，因为这需要\textit{3::Bool}，但3不是一个逻辑值，这是无效的。像\textit{not 3}这样的表达式无法确定类型，也可以说成是包含了一个类型错误，被视为非法表达式。

由于类型推断在求值过程之前，所以Haskell程序是类型安全的，也就是说在求值过程中不会发生类型错误。实际上，类型推断能检查出程序中所占错误比例较高的一类错误，它也是Haskell最有用的特性之一。但是注意使用类型推断并不能消除发生在求值阶段的其他类错误的可能性，比如，表达式\textit{1
'div' 0}可以通过类型推断检查，但在求值阶段报错，因为被0除的行为是未定义的。

类型安全的不足之处在于一些求值阶段成功的表达式却因类型原因而被拒绝。例如，条件表达式\textbf{if} \textit{True} \textbf{then} \textit{1} \textbf{else}
\textit{False}求值结果为1, 但是因包含一个类型错误而被视为无效表达式。
特别是，条件表达式的类型推断规则要求所有可能的结果都具有相同的类型，而在这里例子中，第一种结果为1，是一个数字类型，而第二个结果是False，是一个逻辑值类型。在实践中，程序员很快就学会了如何在类型系统的限制下工作以及如何避免这些问题。

In Hugs, the type of any expression can be displayed by preceding the expression by the command :type . For example:

在Hugs系统中，任意表达式的类型都可以通过\textit{:type}显示出来，例如：

\begin{verbatim}
> :type not
not :: Bool -> Bool

> :type not False
not False :: Bool

> :type not 3
Error
\end{verbatim}

\section{基本类型}
\noindent Haskell提供一套内置到语言中的基本类型，下面是对其中最常用的类型描述：
\\
\\
\textit{Bool}~-~ \textbf{逻辑值}\\
这个类型包含了两个逻辑值\textit{False}和\textit{True}。
\\
\\
\textit{Char}~-~\textbf{字符}\\
这个类型包含了普通键盘上提供的所有单个字符，如'a'，'A'，'3'和\verb|'_'|，以及拥有特殊效果的控制字符，如\verb|'\n'|（移动到新的一行）和\verb|'\t'|（移动到下一个制表位）。与绝大多数其他编程语言标准一样，单个字符必须用单引号'
'括起。
\\
\\
\textit{String}~-~\textbf{字符串}\\
这个类型包含了所有字符序列，诸如"abc"，"1+2=3"以及空字符串""。同样与绝大多数其他编程语言标准一样，字符串必须用双引号"
"括起。
\\
\\
\textit{Int}~-~\textbf{固定精度整数}\\
这个类型包含诸如-100，0以及999这样的整数，计算机以固定大小的内存存储这些值。例如，Hugs系统中Int类型的取值范围在-231和231-1之间。超出这个范围的将得到非预期的结果。例如，在Hugs系统中对\verb|2^31::Int|（使用::将强制结果为Int类型而不是其他的什么数值类型）进行求值将得到一个负值，这是不正确的。
\\
\\
\textit{Integer}~-~\textbf{任意精度整数}\\
该类型包含所有的整数，我们使用足够多的内存储存这个类型的值，从而避免了对该类型值的范围强加上限和下限。例如，使用任何Haskell系统对\verb|2^31::Integer|求值都可以得到正确的结果。

除了对内存和精度的需求不同外，在Int和Integer之间数字类型的选择还是性能考量之一。特别是，大多数电脑都内置了用来处理固定精度整数的硬件，而任意精度的整数通常必须被看成数字序列，通过速度较慢的软件来处理。
\\
\\
\textit{Float}~-~\textbf{单精度浮点数}\\
这个类型包含带小数点的数字，诸如-12.34，1.0以及3.14159，计算机以固定大小内存存储这些值。浮点一词源于这样一个事实：即小数点后允许的数字位数取决于数的大小。例如使用Hugs对\textit{sqrt 2 :: Float}求值结果为1.41421（库函数sqrt用于计算一个数的平方根），其中小数点后有五位数字;而对\textit{sqrt 99999::Float}求值结果为316.226，小数点后则只有三位数字。采用浮点数编程是一个专家话题，需要认真对待舍入误差。在这段介绍性的文字中我们对这种类型讲解的很少。

最后，我们注意到一个单个数字可能拥有不止一种数值类型。例如，3 :: \textit{Int}，3 :: \textit{Integer}和3 :: \textit{Float}对于数字3来说都是有效的类型。这就提出了一个有趣的问题：这些数字在类型推断过程中究竟应该被分配什么类型？这个问题将在本章后面考量类型类时回答。

\section{List类型}
\textit{list}是一个拥有相同类型元素的序列，其元素括在方括号中，并使用逗号分隔。我们将元素类型为T的所有list类型写作[\textit{T}]。比如：

\begin{verbatim}
[False, True, False ] :: [Bool]
[’a’, ’b’, ’c’, ’d’] :: [Char]
["One", "Two", "Three"] :: [String]
\end{verbatim}

在一个list中的元素的个数称为list的\textit{长度}。长度为零的list[]称为空list，而长度为1的lists，如[False]和['a']，称为singleton lists。注意[[]]和[]是不同的list，前者是singleton list，由唯一一个empty list元素组成，而后者则是一个empty list。

关于list类型需进一步注意三点内容。首先，list类型没有传达其长度信息。例如，[\textit{False,
True}]和[\textit{False, True,
False}]两者都是[\textit{Bool}]类型，即使他们的长度不同。其次，没有关于list中元素类型的限制。目前我们局限在一个我们可以给出的有限范围的例子里，因为到目前为止我们介绍的唯一的非基本类型就是list类型，但是我们可以拥有元素为list的list，诸如：
\begin{verbatim}
[[’a’, ’b’], [’c’, ’d’, ’e’]] :: [[Char ]]
\end{verbatim}
最后，没有任何限制要求一个list必须是有限长度的。特别是，由于在Haskell中使用了惰性求值，具有无限长度的list将正如我们在第12章看到的那样，是自然且实用的。

\section{Tuple类型}
\textit{tuple}是一个可拥有不同类型components的有限长度序列，其components括在圆括号中，并使用逗号分隔。我们用(\textit{$T_1,T_2,...,T_n$})表示所有tuple类型。对于任意i，其取值范围从1到\textit{n}，第i个component拥有类型$T_i$。例如：
\begin{verbatim}
(False, True) :: (Bool, Bool)
(False, ’a’, True) :: (Bool, Char , Bool)
("Yes", True, ’a’) :: (String, Bool , Char)
\end{verbatim}

tuple中components的数量称为arity。arity为0的tuple
()称为空tuple。arity为2的tuples称为pairs。arity为3的tuples称为triples，等等。arity为1的tuple，例如(\textit{False})，是不允许使用的，因为它们将与显式设置求值顺序的括号的使用相冲突，如在表达式(1
+ 2) * 3中。

与list类型一样，关于tuple类型也有三点需要进一步注意的内容。首先tuple类型传达了arity信息。例如，类型(\textit{Bool,
Char})包含了所有由第一个component为Bool并且第二个component为Char组成的pairs。其次，没有关于tuple中component的类型的限制。例如，我们有以tuple为components的tuple，以list为components的tuple和以tuple为元素的list：

\begin{verbatim}
(’a’, (False, ’b’)) :: (Char , (Bool , Char ))
([’a’, ’b’], [False, True ]) :: ([Char ], [Bool ])
[(’a’, False), (’b’, True)] :: [(Char , Bool )]
\end{verbatim}

最后，注意tuple必须具有有限长度，以保证tuple类型总是在求值之前被计算得到。

\section{函数类型}
函数是由一个类型的参数到另一种类型的结果的映射。我们用\textit{$T_1->T_2$}表示所有将$T_1$类型参数映射为$T_2$类型结果的函数。例如：
\begin{verbatim}
not :: Bool -> Bool
isDigit :: Char -> Bool
\end{verbatim}

（库函数\textit{isDigit}判断一个字符是否是一个数字）因为对函数的参数和结果类型没有任何限制，带有一个参数和结果的函数的简单符号已经足以应付多参数和结果的情况了，只需将多个值使用list或tuple打包即可。例如，我们下面定义函数\textit{add}用于计算一整数对的和;定义函数\textit{zeroto}返回一个从0到一给定上限值的整数list：

\begin{verbatim}
add :: (Int, Int) -> Int
add (x , y) = x + y
zeroto :: Int -> [Int ]
zeroto n = [0 . . n ]
\end{verbatim}

在这些例子中我们遵循了Haskell将函数类型放在函数定义之前作为文档参考的惯例。系统将检查由用户手工提供的类型与类型推断自动计算出的类型两者之间的一致性。

注意没有限制要求函数一定要对它们的参数类型总是有意义。也就是说，对于函数的某些参数来说，其结果是未定义的。比如当list为空时，库函数\textit{head}从一个list中选出第一个元素的行为就是未定义的。

\section{curried函数}
函数可以自由将函数作为结果返回，利用这个事实，拥有多个参数的函数也可以使用另外一种不太明显的方式处理。例如，考虑下面的定义：

\begin{verbatim}
add' :: Int -> (Int -> Int)
add' x y = x + y
\end{verbatim}

类型指出\textit{add'}是一个函数，其参数类型为\textit{Int}，返回结果类型为一个类型为\textit{Int
->
Int}的函数。定义本身表明\textit{add'}以整数\textit{x}为参数，后面跟着一个整数\textit{y}，返回结果为\textit{x
+
y}。更确切地说，\textit{add'}以整数\textit{x}为参数，返回一个以整数y为参数且返回\textit{x
+ y}的函数。

注意函数\textit{add'}产生的最终结果与上一节中的函数\textit{add}相同。然而函数\textit{add}将其两个参数打包为一个pair一次处理完毕，而函数\textit{add'}则一次仅接受处理一个参数。正如这两个函数的类型所反映的：

\begin{verbatim}
add :: (Int, Int) -> Int
add' :: Int -> (Int -> Int)
\end{verbatim}

对于有两个以上参数的函数，也可以使用同样的技术处理，通过返回以函数为返回值的函数，等等。例如，函数\textit{mult}接受三个参数，每次接受一个，并返回它们的乘积，可以定义如下：
\begin{verbatim}
mult :: Int -> (Int -> (Int -> Int))
mult x y z = x * y * z
\end{verbatim}

这个定义表明\textit{mult}接受整数\textit{x}并返回一个函数，后者依次接受整数\textit{y}并返回另外一个函数，最后这个函数接受整数\textit{z}，并最终返回结果\textit{x * y * z}。

诸如\textit{add'}和\textit{mult}这样的每次接受一个参数的函数被称为\textit{curried}。除了本身有吸引力之外，curried函数也比接受tuple作为参数的函数更加灵活，因为一些有用的函数通常可以通过\textit{部分应用}到参数不完整的curried函数来实现。例如，一个完成递增功能的函数可以通过只需一个参数的curried函数\textit{add'}的部分应用\text{add
1 :: Int -> Int}实现。

为避免在使用curried函数工作时过度使用括号，我们采纳了两个简单的惯例。首先，类型中使用的箭头->是右结合的，例如：

\begin{verbatim}
Int -> Int -> Int -> Int
\end{verbatim}
意为
\begin{verbatim}
Int -> (Int -> (Int -> Int))
\end{verbatim}

然而使用空格表示的函数应用则是左结合的，例如：
\begin{verbatim}
mult x y z
\end{verbatim}
意为
\begin{verbatim}
((mult x) y) z
\end{verbatim}

除非显式需要tuple，Haskell中的所有接受多个参数的函数一般都会被定义成curried函数，并且使用上面的两个惯例来减少需要使用的括号的数量。

\section{多态类型}
库函数\textit{length}用于计算任意list的长度，无论list中元素是什么类型的。比如，它可以用于计算整型list、字符串型list甚至是函数类型list的长度：\\
\hspace*{1cm} > $length~[1, 3, 5, 7]$\\
\hspace*{1cm} $4$\\
\hspace*{1cm} > $length~["Yes", "No"]$\\
\hspace*{1cm} $2$\\
\hspace*{1cm} > $length~[isDigit , isLower , isUpper]$\\
\hspace*{1cm} $3$

The idea that length can be applied to lists whose elements have any type is
made precise in its type by the inclusion of a \textit{type
variable}。类型变量必须以小写字母开头，通常命名为\textit{a，b，c}等。例如，\textit{length}的类型如下：\\
\hspace*{1cm} $length :: [a] \rightarrow Int$

即对任意类型\textit{a}，函数\textit{length}具有类型[a]->\textit{[Int]}。包含一个或多个类型变量的类型被称作多态的（“多种形式"）。as
is the expression with such a type。因此[a] -> \textit{Int}是一个多态类型，\textit{length}是一个多态函数。更普遍的是，标准Prelude中提供的很多函数都是多态的，例如：\\
\hspace*{1cm} $fst :: (a, b) \rightarrow a$\\
\hspace*{1cm} $head :: [a] \rightarrow a$\\
\hspace*{1cm} $take :: Int \rightarrow [a] \rightarrow [a]$\\
\hspace*{1cm} $zip :: [a] \rightarrow [b] \rightarrow [a, b]$\\
\hspace*{1cm} $id :: a \rightarrow a$


