\XeTeXinputencoding "GBK"                                   % 本文件采用GBK编码

\chapter{类型和类}
在这一章节中，我们将介绍Haskell中两个最基础的概念：类型和类。我们首先解释什么是类型以及在Haskell中如何使用它，然后介绍一些基本类型以及使用这些基本类型构造更大的类型的方法，详细讨论函数类型，最后介绍一下多态类型和类型类。

\section{基本概念}
\textit{类型}是一组相关值的集合。例如，类型Bool包含两个逻辑值\textit{False}和\textit{True}，而类型\textit{Bool
->
Bool}则包含了所有将Bool类型参数映射为Bool类型结果的函数，如逻辑非函数\textit{not}。我们使用符号\textit{v::T}来表示\textit{v}是类型\textit{T}的一个值，并可说成\textit{v}具有类型\textit{T}。例如：

\begin{verbatim}
False :: Bool
True :: Bool
not :: Bool -> Bool
\end{verbatim}

更一般的是，符号::也可以用于尚未被求值的表达式，这种情况下，e::\textit{T}意为对表达式\textit{e}求值将产生一个类型\textit{T}的值。例如：

\begin{verbatim}
not False :: Bool
not True :: Bool
not (not False):: Bool
\end{verbatim}

在Haskell中，每个表达式必须有一个类型，该类型通过一个先于表达式求值的过程计算得到，这个过程被称为\textit{类型推断}。这个过程的关键在于一个函数应用的类型规则。其中规定如果f是一个将类型A参数映射为类型B结果的函数，e是一个A类型的表达式，那么f~~e具有类型B：\\
\\
$\dfrac{f::A->B~~e::A}{f~e::B}$
\\
\\
例如，\textit{not False::Bool}可通过这样的规则推断，该规则使用了这样的事实：\textit{not::Bool->Bool}和\textit{False::Bool}。另一方面，表达式\textit{not 3}通过上述规则无法推断类型，因为这需要\textit{3::Bool}，但3不是一个逻辑值，这是无效的。像\textit{not 3}这样的表达式无法确定类型，也可以说成是包含了一个类型错误，被视为非法表达式。

由于类型推断在求值过程之前，所以Haskell程序是类型安全的，也就是说在求值过程中不会发生类型错误。实际上，类型推断能检查出程序中所占错误比例较高的一类错误，它也是Haskell最有用的特性之一。但是注意使用类型推断并不能消除发生在求值阶段的其他类错误的可能性，比如，表达式\textit{1
'div' 0}可以通过类型推断检查，但在求值阶段报错，因为被0除的行为是未定义的。

类型安全的不足之处在于一些求值阶段成功的表达式却因类型原因而被拒绝。例如，条件表达式\textbf{if} \textit{True} \textbf{then} \textit{1} \textbf{else}
\textit{False}求值结果为1, 但是因包含一个类型错误而被视为无效表达式。
特别是，条件表达式的类型推断规则要求所有可能的结果都具有相同的类型，而在这里例子中，第一种结果为1，是一个数字类型，而第二个结果是False，是一个逻辑值类型。在实践中，程序员很快就学会了如何在类型系统的限制下工作以及如何避免这些问题。

In Hugs, the type of any expression can be displayed by preceding the expression by the command :type . For example:

在Hugs系统中，任意表达式的类型都可以通过\textit{:type}显示出来，例如：

\begin{verbatim}
> :type not
not :: Bool -> Bool

> :type not False
not False :: Bool

> :type not 3
Error
\end{verbatim}

\section{基本类型}
\noindent Haskell提供一套内置到语言中的基本类型，下面是对其中最常用的类型描述：
\\
\\
\textit{Bool}~-~ \textbf{逻辑值}\\
这个类型包含了两个逻辑值\textit{False}和\textit{True}。
\\
\\
\textit{Char}~-~\textbf{字符}\\
这个类型包含了普通键盘上提供的所有单个字符，如'a'，'A'，'3'和\verb|'_'|，以及拥有特殊效果的控制字符，如\verb|'\n'|（移动到新的一行）和\verb|'\t'|（移动到下一个制表位）。与绝大多数其他编程语言标准一样，单个字符必须用单引号'
'括起。
\\
\\
\textit{String}~-~\textbf{字符串}\\
这个类型包含了所有字符序列，诸如"abc"，"1+2=3"以及空字符串""。同样与绝大多数其他编程语言标准一样，字符串必须用双引号"
"括起。
\\
\\
\textit{Int}~-~\textbf{固定精度整数}\\
这个类型包含诸如-100，0以及999这样的整数，计算机以固定大小的内存存储这些值。例如，Hugs系统中Int类型的取值范围在-231和231-1之间。超出这个范围的将得到非预期的结果。例如，在Hugs系统中对\verb|2^31::Int|（使用::将强制结果为Int类型而不是其他的什么数值类型）进行求值将得到一个负值，这是不正确的。
\\
\\
\textit{Integer}~-~\textbf{任意精度整数}\\
该类型包含所有的整数，我们使用足够多的内存储存这个类型的值，从而避免了对该类型值的范围强加上限和下限。例如，使用任何Haskell系统对\verb|2^31::Integer|求值都可以得到正确的结果。

除了对内存和精度的需求不同外，在Int和Integer之间数字类型的选择还是性能考量之一。特别是，大多数电脑都内置了用来处理固定精度整数的硬件，而任意精度的整数通常必须被看成数字序列，通过速度较慢的软件来处理。
\\
\\
\textit{Float}~-~\textbf{单精度浮点数}\\
这个类型包含带小数点的数字，诸如-12.34，1.0以及3.14159，计算机以固定大小内存存储这些值。浮点一词源于这样一个事实：即小数点后允许的数字位数取决于数的大小。例如使用Hugs对\textit{sqrt 2 :: Float}求值结果为1.41421（库函数sqrt用于计算一个数的平方根），其中小数点后有五位数字;而对\textit{sqrt 99999::Float}求值结果为316.226，小数点后则只有三位数字。采用浮点数编程是一个专家话题，需要认真对待舍入误差。在这段介绍性的文字中我们对这种类型讲解的很少。

最后，我们注意到一个单个数字可能拥有不止一种数值类型。例如，3 :: \textit{Int}，3 :: \textit{Integer}和3 :: \textit{Float}对于数字3来说都是有效的类型。这就提出了一个有趣的问题：这些数字在类型推断过程中究竟应该被分配什么类型？这个问题将在本章后面考量类型类时回答。

\section{List类型}
\textit{list}是一个拥有相同类型元素的序列，其元素括在方括号中，并使用逗号分隔。我们将元素类型为T的所有list类型写作[\textit{T}]。比如：

\begin{verbatim}
[False, True, False ] :: [Bool]
[’a’, ’b’, ’c’, ’d’] :: [Char]
["One", "Two", "Three"] :: [String]
\end{verbatim}

在一个list中的元素的个数称为list的\textit{长度}。长度为零的list[]称为空list，而长度为1的lists，如[False]和['a']，称为singleton lists。注意[[]]和[]是不同的list，前者是singleton list，由唯一一个empty list元素组成，而后者则是一个empty list。

关于list类型需进一步注意三点内容。首先，list类型没有传达其长度信息。例如，[\textit{False,
True}]和[\textit{False, True,
False}]两者都是[\textit{Bool}]类型，即使他们的长度不同。其次，没有关于list中元素类型的限制。目前我们局限在一个我们可以给出的有限范围的例子里，因为到目前为止我们介绍的唯一的非基本类型就是list类型，但是我们可以拥有元素为list的list，诸如：
\begin{verbatim}
[[’a’, ’b’], [’c’, ’d’, ’e’]] :: [[Char ]]
\end{verbatim}
最后，没有任何限制要求一个list必须是有限长度的。特别是，由于在Haskell中使用了惰性求值，具有无限长度的list将正如我们在第12章看到的那样，是自然且实用的。

\section{Tuple类型}
\textit{tuple}是一个可拥有不同类型components的有限长度序列，其components括在圆括号中，并使用逗号分隔。我们用(\textit{$T_1,T_2,...,T_n$})表示所有tuple类型。对于任意i，其取值范围从1到\textit{n}，第i个component拥有类型$T_i$。例如：
\begin{verbatim}
(False, True) :: (Bool, Bool)
(False, ’a’, True) :: (Bool, Char , Bool)
("Yes", True, ’a’) :: (String, Bool , Char)
\end{verbatim}

tuple中components的数量称为arity。arity为0的tuple
()称为空tuple。arity为2的tuples称为pairs。arity为3的tuples称为triples，等等。arity为1的tuple，例如(\textit{False})，是不允许使用的，因为它们将与显式设置求值顺序的括号的使用相冲突，如在表达式(1
+ 2) * 3中。

与list类型一样，关于tuple类型也有三点需要进一步注意的内容。首先tuple类型传达了arity信息。例如，类型(\textit{Bool,
Char})包含了所有由第一个component为Bool并且第二个component为Char组成的pairs。其次，没有关于tuple中component的类型的限制。例如，我们有以tuple为components的tuple，以list为components的tuple和以tuple为元素的list：

\begin{verbatim}
(’a’, (False, ’b’)) :: (Char , (Bool , Char ))
([’a’, ’b’], [False, True ]) :: ([Char ], [Bool ])
[(’a’, False), (’b’, True)] :: [(Char , Bool )]
\end{verbatim}

最后，注意tuple必须具有有限长度，以保证tuple类型总是在求值之前被计算得到。

\section{函数类型}

