\chapter{定义函数}
在本章中我们将介绍一些在Haskell中定义函数的机制。我们首先介绍条件表达式和守卫等式，然后介绍一种简单却强大的模式匹配思想，最后
介绍lambda表达式和段的概念。

\section{以旧造新}
也许定义新函数最直接的方法就是简单地将已有的一个或多个函数结合起来。例如，下面展示的一些库函数就是用这种方法定义的：

\begin{itemize}
\item 判断一个字符是否是数字

\hspace*{1cm} $isDigit~::~Char \rightarrow Bool$\\
\hspace*{1cm} $isDigit~c~=~c \geq '0'~~\&\&~~c \leq '9'$

\item 判断一个整数是否是偶数

\hspace*{1cm} $even~::~Integral~a \Rightarrow a \rightarrow Bool$\\
\hspace*{1cm} $even~c~=~n~`mod`~2 == 0$

\item 将一个列表在第$n$th个元素处拆分

\hspace*{1cm} $splitAt~::~Int \rightarrow [a] \rightarrow ([a],~[a])$\\
\hspace*{1cm} $splitAt~n~xs~=~(take~n~xs,~drop~n~xs)$

\item 倒数

\hspace*{1cm} $recip~::~Fractional~a \Rightarrow a \rightarrow a$\\
\hspace*{1cm} $recip~n~=~1~/~n$

\end{itemize}

注意上面$even$和$recip$类型中类约束的使用，精确的指明了这两个函数可以分别应用于任何整数类型和分数类型。

\section{条件表达式}
有一类函数，它们从许多种可能的结果中选择出一个最终结果，Haskell提供了很多不同的方式来定义这类函数。
最简单的方式就是使用\textit{条件表达式}，
条件表达式使用被称为\textit{条件}的逻辑表达式在两个相同类型的结果中选出一个。如果条件为\textit{真}，就选中第一个结果，否则选中第二个。例如：库函数$abs$的定义如下，该函数返回一个整数的绝对值：

\noindent\hspace*{1cm}$abs~::~Int \rightarrow Int$\\
\hspace*{1cm}$abs~n~=~\textbf{if}~n~ \geq ~0~ \textbf{then}~n~ \textbf{else} -n $

条件表达式可以嵌套，它们可以包含其他条件表达式。例如，库函数$signum$定义如下，它用来返回一个整型数的符号：

\noindent\hspace*{1cm}$signum~::~Int \rightarrow Int$\\
\hspace*{1cm}$signum~n~=~\textbf{if}~n~<~0~\textbf{then}~-1~\textbf{else} $\\
\hspace*{4cm}$\textbf{if}~n~==~\textbf{then}~0~\textbf{else}~1$

注意，与某些编程语言中的条件表达式不同，Haskell中的条件表达式必须包含\textbf{else}分支，这样就避免了众所周知的“else悬挂”问题。例如，如果\textbf{else}分支是可选的，那么表达式$\textbf{if}~True~\textbf{then~if}~False~\textbf{then}~1~\textbf{else}~2$既可以返回结果2，也可能产生一个错误，这取决于表达式中的\textbf{else}分支是被看作是内部条件表达式的一部分还是被看作是外部条件表达式的一部分。

\section{守卫等式}
作为条件表达式的一种替代方案，函数还可以使用\textit{守卫等式}来定义。在这类函数中，我们使用一些被称为\textit{守卫}的逻辑表达式从一些类型相同的结果中选择函数的最终结果。如果第一个守卫等式为\textit{真}，那么第一个结果被选中；否则如果第二个守卫等式为\textit{真}，则第二个结果被选中，依此类推。例如，库函数$abs$也可以以下面的方式定义： 

\begin{tabular}[t]{lll}
$abs~n~$&$|~n\geq 0$&$= ~ n$\\
&$|~otherwise$&$=~-n$\\
\end{tabular}

符号|读作“满足于，使得”。守卫$otherwise$在标准Prelude库文件中简单地定义为$otherwise~=~True$。虽然以$otherwise$作为一系列守卫的结尾不是必要的，但这样做为处理“所有其他情况”提供了一种便利的方式，同时也清楚地避免了因所有守卫都不为真而出错的情况。

较之条件表达式，使用守卫等式定义函数可读性更好。例如：使用如下守卫等式定义的库函数$signum$更容易理解。

\begin{tabular}[t]{lll}
$signum~n$&$|~n~<~0$&$=~-1$\\
&$|~n~==~0$&$=~0$\\
&$|~otherwise$&$=~1$\\
\end{tabular}

\section{模式匹配}

使用\textit{模式匹配}许多函数拥有一个极为简单且直观的定义。在这类函数定义中，我们使用一些被称为\textit{模式}的语法表达式从一些类型相同的结果中选择出函数的最终结果。如果第一个模式匹配成功，那么第一个结果被选中；否则，如果第二个模式匹配成功，那么第二个结果被选中，依此类推。例如，库函数$not$的定义如下，它用来返回一个对逻辑值取非的结果：

\begin{tabular}[t]{lll}
$not$&::&$Bool \rightarrow Bool$\\
$not~False$&=&$True$\\
$not~True$&=&$False$\\
\end{tabular}

接受多个参数的函数也可以使用模式匹配定义，这种情况下，每个等式中各个参数的模式按顺序进行匹配。例如，库操作符$\&\&$定义如下，该操作符返回两个逻辑值与后的结果：

\begin{tabular}[t]{lll}
$(\&\&)$&::&$Bool \rightarrow Bool \rightarrow Bool$\\
$True~\&\&~True$&=&$True$\\
$True~\&\&~False$&=&$False$\\
$False~\&\&~True$&=&$False$\\
$False~\&\&~False$&=&$False$\\
\end{tabular}

然而，我们可以通过将最后三个等式合并为一个等式来简化这个函数的定义，合并后的等式使用可匹配任何值的\textit{通配符}模式$\_$，并返回与两个参数值无关的结果$False$。

\begin{tabular}[t]{lll}
$True~\&\&~True$&=&$True$\\
$\_~\&\&~\_$&=&$False$\\
\end{tabular}

根据第12章讨论的惰性求值，这个版本的函数定义还有这样的好处：如果第一个参数为$False$，那么我们可直接返回结果$False$,而无须对第二个参数进行求值。在实际中，标准库prelude使用了同样具有这个属性的等式定义$\&\&$。但只使用了第一个参数的值来选择哪个等式作为最终结果：

\begin{tabular}[t]{lll}
$True~\&\&~b$&=&$True$\\
$False~\&\&~\_$&=&$False$\\
\end{tabular}

即如果第一个参数为$True$，那么结果为第二个参数的值；如果第一个参数为$False$，那么结果就是$False$。

注意，因技术原因在一个等式中同样的名字不能被用于多个参数。例如，下面的操作符$\&\&$的定义就是基于这个观察：如果两个参数相等，那么结果也是同样的值，否则结果为$False$。但是由于上面的命名要求，这个定义是无效的：

\begin{tabular}[t]{lll}
$b~\&\&~b$&=&$b$\\
$\_~\&\&~\_$&=&$False$\\
\end{tabular}

然而如果需要，我们可以使用守卫等式来定义一个有效的版本，守卫等式用来判断两个参数是否相等：

\begin{tabular}[t]{lll}
$b~\&\&~c$ & $|~b~==~c$ &= $b$\\
& $|otherwise$ &= $False$\\
\end{tabular}

到目前为止，我们只考虑了基本模式，要么是值、要么是变量或是通配符模式。在本节其余部分，我们将介绍三种有用的将较小模式结合成较大模式的方法。

\subsection*{元组模式}
一个模式元组的本身就是一个模式，它可以匹配任何元数相同且所有元素都可按顺序匹配对应模式的元组。例如，库函数$fst$和$snd$定义如下，它们分别返回二元组的第一个和第二个元素：

\begin{tabular}[t]{lll}
$fst$&::&$(a,~b) \rightarrow a$\\
$fst~(x,~\_)$&=&$x$\\
\end{tabular}

\begin{tabular}[t]{lll}
$snd$&::&$(a,~b) \rightarrow b$\\
$snd~(\_,~y)$&=&$y$\\
\end{tabular}

\subsection*{列表模式}
同样，一个模式列表本身是一个模式，它可以匹配任何长度相同且所有原则都可按顺序匹配对应模式的列表。例如，用来判断一个列表是否精确的包含三个元素且第一个元素为'$a$'的函数$test$定义如下：

\begin{tabular}[t]{lll}
$test$&::&$[Char] \rightarrow Bool$\\
$test~['a',~\_,~\_]$&=&$True$\\
$test~\_$&=&$False$\\
\end{tabular}

到目前为止，我们一直将列表视为Haskell内置的原子类型。但事实上并非如此，它们实际上是使用操作符$:$从空列表[~]开始一次一个元素的构造起来的。操作符$:$被称为$cons$，它通过将一个新元素加到一个已存在列表的开始处来构造一个新的列表。例如，列表$[1,~2,~3]$可以按如下分解：

\noindent\hspace*{1cm} $[1,~2,~3]$\\
\hspace*{1cm} = \{列表记法\}\\
\hspace*{1cm} $1~:~[2,~3]$\\
\hspace*{1cm} = \{列表记法\}\\
\hspace*{1cm} $1~:~(2:~[3])$\\
\hspace*{1cm} = \{列表记法\}\\
\hspace*{1cm} $1~:~(2:~(3:~[]))$

即$[1,~2,~3]$只是$1~:~(2~:~(3~:~[~]))$的一个缩写。为了避免在使用这样的列表时过度使用括号，cons操作符被假定为是右结合的。例如，$1:~2:~3:~[~]$意为$1:~(2:~
(3:~ [~]))$。

cons操作符不仅可以用来构造列表，也可以用来构造模式，用于匹配任何非空且第一个元素及其余元素都可按顺序匹配对应模式的列表。例如，我们现在可以定义一个更通用的函数$test$的版本，用于判断包含任意数量字符的列表是否以'$a$'开头： 

\begin{tabular}[t]{lll}
$test$&::&$[Char] \rightarrow Bool$\\
$test~['a'~:~\_]$&=&$True$\\
$test~\_$&=&$False$\\
\end{tabular}

同样，库函数$null$，$head$和$tail$的定义如下，它们分别用于判断一个列表是否为空，从一个非空列表中选出第一个元素以及从一个非空列表中删除第一个元素：

\begin{tabular}[t]{lll}
$null$&::&$[a] \rightarrow Bool$\\
$null~[~]$&=&$True$\\
$null~(\_:\_)$&=&$False$\\
\end{tabular}

\begin{tabular}[t]{lll}
$head$&::&$[a] \rightarrow a$\\
$head~[x:\_]$&=&$x$\\
\end{tabular}

\begin{tabular}[t]{lll}
$tail$&::&$[a] \rightarrow a$\\
$tail~[\_:~xs]$&=&$xs$\\
\end{tabular}

注意cons操作符必须用括号括上，因为函数优先级高于所有其他操作符。例如，不带括号的定义$tail~:~xs~=~xs$意为$(tail)~:~xs~=~xs$，它不仅含义不正确，而且还是一个无效的定义。
