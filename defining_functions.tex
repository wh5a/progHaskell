\chapter{定义函数}
在本章中我们将介绍一些在Haskell中定义函数的机制。我们首先介绍条件表达式和守卫等式，然后介绍一种简单却强大的模式匹配思想，最后
介绍lambda表达式和段的概念。

\section{以旧造新}
也许定义新函数最直接的方法就是简单地将已有的一个或多个函数结合起来。例如，下面展示的一些库函数就是用这种方法定义的：

\begin{itemize}
\item 判断一个字符是否是数字

\hspace*{1cm} $isDigit~::~Char \rightarrow Bool$\\
\hspace*{1cm} $isDigit~c~=~c \geq '0'~~\&\&~~c \leq '9'$

\item 判断一个整数是否是偶数

\hspace*{1cm} $even~::~Integral~a \Rightarrow a \rightarrow Bool$\\
\hspace*{1cm} $even~c~=~n~`mod`~2 == 0$

\item 将一个列表在第$n$th个元素处拆分

\hspace*{1cm} $splitAt~::~Int \rightarrow [a] \rightarrow ([a],~[a])$\\
\hspace*{1cm} $splitAt~n~xs~=~(take~n~xs,~drop~n~xs)$

\item 倒数

\hspace*{1cm} $recip~::~Fractional~a \Rightarrow a \rightarrow a$\\
\hspace*{1cm} $recip~n~=~1~/~n$

\end{itemize}

注意上面$even$和$recip$类型中类约束的使用，精确的指明了这两个函数可以分别应用于任何整数类型和分数类型。

\section{条件表达式}
有一类函数，它们从许多种可能的结果中选择出一个最终结果，Haskell提供了很多不同的方式来定义这类函数。
最简单的方式就是使用\textit{条件表达式}，
条件表达式使用被称为\textit{条件}的逻辑表达式在两个相同类型的结果中选出一个。如果条件为\textit{真}，就选中第一个结果，否则选中第二个。例如：库函数$abs$的定义如下，该函数返回一个整数的绝对值：

\noindent\hspace*{1cm}$abs~::~Int \rightarrow Int$\\
\hspace*{1cm}$abs~n~=~\textbf{if}~n~ \geq ~0~ \textbf{then}~n~ \textbf{else} -n $

条件表达式可以嵌套，它们可以包含其他条件表达式。例如，库函数$signum$定义如下，它用来返回一个整型数的符号：

\noindent\hspace*{1cm}$signum~::~Int \rightarrow Int$\\
\hspace*{1cm}$signum~n~=~\textbf{if}~n~<~0~\textbf{then}~-1~\textbf{else} $\\
\hspace*{4cm}$\textbf{if}~n~==~\textbf{then}~0~\textbf{else}~1$

注意，与某些编程语言中的条件表达式不同，Haskell中的条件表达式必须包含\textbf{else}分支，这样就避免了众所周知的“else悬挂”问题。例如，如果\textbf{else}分支是可选的，那么表达式$\textbf{if}~True~\textbf{then~if}~False~\textbf{then}~1~\textbf{else}~2$既可以返回结果2，也可能产生一个错误，这取决于表达式中的\textbf{else}分支是被看作是内部条件表达式的一部分还是被看作是外部条件表达式的一部分。

\section{守卫等式}
作为条件表达式式的备选方案，函数还可以通过\textit{守卫等式}的方式来定义。在这种方式中，我们定义一系列相同类型的、有序的逻辑表达式，并称之为\textit{守卫}，然后在这些守卫中选择我们的结果。我们首先计算第一个守卫，如果为\textit{真}，第一个结果被选中，否则计算第二个守卫，如果为真，第二个结果被选中，依次类推。比如：库函数$abs$还可以以下面的方式定义。

\begin{tabular}[t]{lll}
$abs~n~$&$|~n\geq 0$&$= ~ n$\\
&$|~otherwise$&$=~-n$\\
\end{tabular}

符号|可读作“满足于，使得”。最后一个守卫$otherwise$仅仅是在库文件定义为$otherwise~=~True$，虽然不必使用$otherwise$最为一系列守卫的结尾，但这样做为处理“所有其他条件”提供了便利，同时，前面的守卫可能都不为真，这种情况下如果没有$otherwise$，将会产生一个错误。

较之条件表达式，守卫等式更具有易读性，例如：使用守卫等式定义的库函数$signum$更容易理解。


\begin{tabular}[t]{lll}
$signum~n$&$|~n~<~0$&$=~-1$\\
&$|~n~==~0$&$=~0$\\
&$|~otherwise$&$=~1$\\
\end{tabular}

